---
import { gacha_map } from "@/contents/data";
import { getDateOffset, now } from "~/lib/date";
import { sum } from "~/lib/math";
import { useCalendar } from "~/lib/unpoly/compiler/calendar/helper";
import { regionValue } from "~/lib/utilities";
import { calculateEvents } from "../_calculate";
import OptionsBadge from "../_components/options-badge.astro";
import { STARS_FROM_DAILY_LOGIN } from "../_constants";
import { getOptions } from "../_options";

export const partial = true;

const gacha = gacha_map.get(Astro.params.gacha_id!);
if (!gacha) {
	return new Response("Gacha not found.", { status: 404 });
}

const options = await getOptions(Astro);
const events = regionValue.unwrap(gacha.events)!;
const calculatedEvents = calculateEvents(
	[...events.past, events.active],
	options,
);

const dateOffset = getDateOffset((events.past.at(0) ?? events.active!).startAt);

const RRULE_DAYS = ["MO", "TU", "WE", "TH", "FR", "SA", "SU"];
const getRruleDay = (idx: number) => {
	const today = now().day();
	return RRULE_DAYS[(today + (idx - 1)) % 7];
};
const createRecurrenceEvent = (
	id: string,
	title: string,
	reward: string,
	days: number[],
) => {
	const maxDate = calculatedEvents.at(-1)!.data.endAt.jp.add(dateOffset);
	const startDate = now().add(days[0], "days");
	if (startDate.isAfter(maxDate, "days")) return;

	const until = maxDate.format("YYYYMMDD");
	const byday = days.map((idx) => getRruleDay(idx)).join(",");

	return {
		id,
		title: `${title} (${reward})`,
		start: Temporal.PlainDate.from(startDate.format()),
		end: Temporal.PlainDate.from(startDate.format()),
		rrule: `FREQ=WEEKLY;UNTIL=${until};BYDAY=${byday}`,
		calendarId: "passive-stars",
	};
};

const calendar = useCalendar({
	options,
	events: calculatedEvents
		.map(({ data, ...stars }) => ({
			event: data,
			total: sum(Object.values(stars)),
		}))
		.filter(({ total }) => total > 0)
		.map(({ event, total }) => ({
			id: event.id,
			title: `${event.name} (${total}★)`,
			start: Temporal.PlainDate.from(event.startAt.jp.add(dateOffset).format()),
			end: Temporal.PlainDate.from(event.endAt.jp.add(dateOffset).format()),
			calendarId: "event-stars",
		})),
	recurrenceEvents: [
		...(!options.daily_login
			? []
			: [
					createRecurrenceEvent(
						"daily_login",
						"Daily Login",
						"50★",
						STARS_FROM_DAILY_LOGIN.map((star, idx) => ({ idx, star }))
							.filter(({ star }) => star > 0)
							.map(({ idx }) => idx + 1),
					),
				]),
		...(!options.daily_live
			? []
			: [createRecurrenceEvent("daily_live", "Daily Live", "1× Pull", [7])]),
	].filter((it) => it !== undefined),
});
---

<main>
	<div
		class="my-4 inline-flex w-full flex-wrap justify-center gap-1 text-center font-medium"
	>
		<OptionsBadge
			name="Point"
			value={options.target_point}
			formattedValue={`≥${options.target_point}`}
		/>
		<OptionsBadge
			name="Rank"
			value={options.target_rank}
			formattedValue={`≤${options.target_rank}`}
		/>
		<OptionsBadge name="Story" value={options.read_event_story} />
		<OptionsBadge
			name="Daily Login"
			value={options.daily_login}
			badgeClass="badge-secondary"
		/>
		<OptionsBadge
			name="Daily Live"
			value={options.daily_live}
			badgeClass="badge-secondary"
		/>
	</div>

	<div class="overflow-x-auto">
		<div {...calendar}></div>
	</div>
</main>
