---
import { gacha_map, LATEST_EVENT_RELEASE_GAP } from "@/contents/data";
import NextPageButton from "~/components/next-page-button.astro";
import BaseLayout from "~/layouts/base-layout.astro";
import { getGachaBanner, getSongAlbumCover } from "~/lib/assets";
import { dayjs } from "~/lib/date";
import { sum } from "~/lib/math";
import { paginate } from "~/lib/paginate";
import { calculateSongs, isOnlySpecialRelease } from "./_calculate";
import OptionsBadge from "./_components/options-badge.astro";
import { getOptions } from "./_options";

const gacha = gacha_map.get(Astro.params.gacha_id!);
if (!gacha) {
	return new Response("Gacha not found.", { status: 404 });
}

const options = await getOptions(Astro);
const { results, page } = paginate({
	context: Astro,
	pageSize: 12,
	items: calculateSongs(gacha.endAt.jp, options).map((it) => ({
		...it,
		total: sum([
			...Object.values(it.fullCombo).map(({ stars }) => stars),
			...Object.values(it.score),
		]),
		releasedAt: isOnlySpecialRelease(it.data)
			? it.data.specialReleasedAt!
			: it.data.releasedAt,
	})),
});
---

<BaseLayout
	title={`Free stars until ${gacha.name} (upcoming songs)`}
	description={`Calculate how much free stars you can get from upcoming songs until ${gacha.name} banner ends`}
	image={(await getGachaBanner(Astro, { gacha })).src}
	class="container mx-auto my-4 flex flex-col items-center gap-y-4 lg:max-w-4xl"
>
	<div
		class="inline-flex w-full flex-wrap justify-center gap-1 text-center font-medium"
	>
		<OptionsBadge name="S Score" value={options.song_s_score} />
		<OptionsBadge name="SS Score" value={options.song_ss_score} />
		<OptionsBadge
			name="Full Combo"
			value={options.song_full_combo_level}
			formattedValue={`Level â‰¤${options.song_full_combo_level}`}
			badgeClass="badge-secondary"
		/>
	</div>

	<div id="song-list">
		<ul class="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
			{
				results.map(
					async ({ data: song, fullCombo, score, total, releasedAt }) => (
						<li class="group card image-full bg-base-100 shadow-sm">
							<figure>
								<img
									{...await getSongAlbumCover(Astro, { song })}
									class="aspect-square w-full"
								/>
							</figure>

							<div class="card-body items-center justify-end text-center">
								<div class="dropdown dropdown-center dropdown-top">
									<div
										tabindex="0"
										role="button"
										class="link card-title line-clamp-1"
									>
										{isOnlySpecialRelease(song) && "(SP)"}
										{song.title}
									</div>

									<div
										tabindex="0"
										class="card card-sm dropdown-content bg-base-100 rounded-box z-1 mb-2 w-72 shadow-sm"
									>
										<div
											tabindex="0"
											class="card-body text-base-content items-center"
										>
											<h2 class="card-title">{song.title}</h2>
											<p class="badge badge-accent">
												JP : {releasedAt.jp.format("DD-MM-YYYY")} /
												{releasedAt.jp.fromNow()}
											</p>

											{releasedAt.en ? (
												<p class="badge badge-primary">
													EN : {releasedAt.en.format("DD-MM-YYYY")} /
													{releasedAt.en.fromNow()}
												</p>
											) : (
												<>
													<p class="badge badge-neutral">
														EN :
														{releasedAt.jp
															.add(LATEST_EVENT_RELEASE_GAP)
															.format("DD-MM-YYYY")}
														/
														{releasedAt.jp
															.add(LATEST_EVENT_RELEASE_GAP)
															.fromNow()}
													</p>
													<p>
														EN (predicted) date assumes
														{"~" +
															Math.round(
																dayjs
																	.duration(LATEST_EVENT_RELEASE_GAP)
																	.asDays(),
															)}
														days difference between JP and EN server.
													</p>
												</>
											)}
										</div>
									</div>
								</div>

								<div class="inline-flex flex-wrap justify-center gap-1">
									{Object.entries(score)
										.filter(([, stars]) => stars > 0)
										.map(([label, stars]) => (
											<span class="badge badge-primary">
												{label.toUpperCase()} &bullet; {stars}&starf;
											</span>
										))}

									{Object.entries(fullCombo).map(
										([difficulty, { level, stars }]) => (
											<span
												data-difficulty={difficulty}
												class="badge badge-primary bg-bandori-difficulty text-bandori-difficulty-content group-hover:bg-bandori-difficulty-alt border-bandori-difficulty"
											>
												{difficulty.toUpperCase()}
												{level} &bullet; {stars}&starf;
											</span>
										),
									)}

									<span class="badge badge-info">Total : {total}&starf;</span>
								</div>
							</div>
						</li>
					),
				)
			}
		</ul>
	</div>

	<NextPageButton {page} item={{ length: results.length, name: "song" }} />
</BaseLayout>
